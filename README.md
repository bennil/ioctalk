# IOC-Talk

Combines dependency injection and remote procedure calls for enterprise architecture implementations without technical dependencies.

[*Nuget with ShortWireFraming(), LegacyWireFraming() and the serializers: BinaryMessageSerializer(), JsonMessageSerializer()*](https://www.nuget.org/packages/ioctalk-codegen-binary-json-tcp)

[*Nuget with ShortWireFraming() and BinaryMessageSerializer()*](https://www.nuget.org/packages/ioctalk-codegen-binary-tcp)

Uses .net code generator for communication proxy auto creation and dependency mapping.
This is a performance improvement by eliminating runtime code generation and runtime assembly type scanning.
The new binary wire format and binary message serializer reduces the transfer size as well.

```csharp
var localShare = new LocalShareContext();

var tcpMyService = new TcpCommunicationController(new ShortWireFraming(), new BinaryMessageSerializer());

var compositionHost = new TalkCompositionHost(localShare, "MyService");

// Maps all transfer interfaces to local implementations or source generated auto implementations
compositionHost.RegisterAutoGeneratedProxyInterfaceMappings();

// Creates a instance of MyServiceImplementation per session
compositionHost.RegisterLocalSessionService<IMyService, MyServiceImplementation>();

// Creates a instance of source generated IMyClientService proxy implementation per session
compositionHost.RegisterRemoteService<IMyClientService>();

// Creates a singleton instance of MyInternalStuffService
compositionHost.RegisterLocalSharedService<IMyInternalStuffService, MyInternalStuffService>();
```


If you need to connect to ioctalk legacy wire format and json serialization services use:
```csharp
new TcpCommunicationController(new LegacyWireFraming(), new JsonMessageSerializer())
```


## Dependency less session handling

How can you react to distributed events (remote endpoint session changes) in your business code without having a dependency to the underlying transfer stack?
The ioctalk solution is "constructor out delegate" injection and convention:

Functional service implementation assembly:
```csharp
	public class MySuperService : IMySuperService
	{
		public MySuperService(out Action<IMySupremeRemoteClientService> clientServiceCreated, 
					out Action<IMySupremeRemoteClientService> clientServiceTerminated)
		{
			clientServiceCreated = OnClientServiceCreated;
			clientServiceTerminated = OnClientServiceTerminated;
		}

		private void OnClientServiceCreated(IMySupremeRemoteClientService client)
		{
			// available remote (or local - depending on the orchestration) client service instance
		}

		private void OnClientServiceTerminated(IMySupremeRemoteClientService client)
		{
		}
	}
```
By convention the ioctalk dependency injection container needs a "Created" or "Terminated" at the end of the method name.

If your service implementation only manages the single session instance, you can also use an `IDisposable` implementation to react on session termination.
Be aware of not calling remote services in your constructor service implementation. Use constructor parameter `(out Action<IMyService> myselfCreated)` for remote interaction after the session is ready (all session instances are created).


Now you have separated your business code from any technical dependency. You can use it with ioctalk, within a unit test or some future transfer technology.




Legacy Nuget Packages: [ioctalk](https://www.nuget.org/packages/ioctalk-standard/)       
			   [ioctalk-AheadOfTimeOnly](https://www.nuget.org/packages/ioctalk-standard-AheadOfTimeOnly/)
			   (No Roslyn dependency required - no auto proxy generation)

