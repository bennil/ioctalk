using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using System;
using System.Collections.Immutable;
using System.Data;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;

namespace IOCTalk.CodeGenerator
{
    [Generator]
    public class IocTalkCodeGenerator : IIncrementalGenerator
    {
        private const string MethodNameRegisterRemoteService = "RegisterRemoteService";
        private const string MethodNameRegisterLocalSessionService = "RegisterLocalSessionService";

        private const string MethodNameIncludeDifferentImplementationAssembly = "IncludeDifferentImplementationAssembly";

        Dictionary<ITypeSymbol, ITypeSymbol>? interfaceClassImplementationMappings = null;
        List<string> differentImplementationAssemblyNames = null;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
#if DEBUG
            //if (!Debugger.IsAttached)
            //{
            //    Debugger.Launch();
            //}

            LogToFileHelper.WriteLog("Initialize source generator");
#endif

            // collect auto gen enabled call indicator
            var autoGenEnabledIndicator = context.SyntaxProvider
                                .CreateSyntaxProvider(CollectRegisterAutoGeneratedProxyInterfaceMappingsDeclarations, GetContextNodeExistsIndicator)
                                .Collect();

            // collect remote services
            var interfaceTypes = context.SyntaxProvider
                    .CreateSyntaxProvider(CollectRegisterRemoteMethods, GetProxyInterface)
                    .Where(type => type is not null)
                    .Collect();


            // collect target assembly name
            var assemblyName = context.CompilationProvider.Select(static (cp, _) => cp.AssemblyName);

            // collect own custom interface implementations
            var implementedInterfaces = context.SyntaxProvider
                .CreateSyntaxProvider(CollectImplementedInterfaceClasses, GetImplementedInterface)
                .Where(type => type is not null)
                 .Collect();


            var localSessionServiceTypes = context.SyntaxProvider
                        .CreateSyntaxProvider(CollectRegisterLocalSessionMethods, GetLocalSessionServiceInterface)
                        .Where(type => type is not null)
                        .Collect();

            var combined = interfaceTypes.Combine(assemblyName).Combine(implementedInterfaces).Combine(localSessionServiceTypes).Combine(autoGenEnabledIndicator);

            context.RegisterSourceOutput(combined, ExecuteGenerateCode);
        }


        private bool CollectRegisterAutoGeneratedProxyInterfaceMappingsDeclarations(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            //Debug.WriteLine(syntaxNode.GetType().Name + ": " + syntaxNode.ToString());


            if (syntaxNode is QualifiedNameSyntax qualifiedName
                && qualifiedName.ToString() == "BSAG.IOCTalk.Composition")
            {
                // activate code gen if ioctalk composition namespace is used
                return true;
            }


            return false;
        }


        private bool GetContextNodeExistsIndicator(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            return context.Node != null;
        }



        private bool CollectRegisterRemoteMethods(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            //Debug.WriteLine(syntaxNode.GetType().Name + ": " + syntaxNode.ToString());


            if (syntaxNode is InvocationExpressionSyntax invokeExp)
            {
                var genericName = invokeExp.DescendantNodes().OfType<GenericNameSyntax>().FirstOrDefault();

                if (genericName != null)
                {
                    string genericNameStr = genericName.ToString();

                    if (genericNameStr.StartsWith(MethodNameRegisterRemoteService))
                    {
                        // ioc talk generic remote service registration
                        return true;
                    }
                }
            }


            return false;
        }



        private bool CollectRegisterLocalSessionMethods(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            //Debug.WriteLine(syntaxNode.GetType().Name + ": " + syntaxNode.ToString());

            if (syntaxNode is InvocationExpressionSyntax invokeExp)
            {
                var genericName = invokeExp.DescendantNodes().OfType<GenericNameSyntax>().FirstOrDefault();

                if (genericName != null)
                {
                    string genericNameStr = genericName.ToString();

                    if (genericNameStr.StartsWith(MethodNameRegisterLocalSessionService))
                    {
                        // ioc talk local session service implementation
                        return true;
                    }
                }
            }

            return false;
        }


        private ITypeSymbol? GetProxyInterface(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var invokeExpr = (InvocationExpressionSyntax)context.Node;

            var symbolInfo = context.SemanticModel.GetSymbolInfo(invokeExpr.Expression, cancellationToken);

            if (symbolInfo.Symbol is IMethodSymbol method)
            {
                if (method.IsGenericMethod
                    && method.Name.Equals(MethodNameRegisterRemoteService))
                {
                    var genericTypeArg0 = method.TypeArguments.FirstOrDefault();

                    if (genericTypeArg0 != null)
                    {
                        return genericTypeArg0;
                    }
                }
            }


            return null;
        }


        private ITypeSymbol? GetLocalSessionServiceInterface(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var invokeExpr = (InvocationExpressionSyntax)context.Node;

            var symbolInfo = context.SemanticModel.GetSymbolInfo(invokeExpr.Expression, cancellationToken);

            if (symbolInfo.Symbol is IMethodSymbol method)
            {
                if (method.IsGenericMethod
                    && method.Name.Equals(MethodNameRegisterLocalSessionService))
                {
                    var genericTypeArg0 = method.TypeArguments.FirstOrDefault();

                    if (genericTypeArg0 != null)
                    {
                        return genericTypeArg0;
                    }
                }
            }


            return null;
        }



        private bool CollectImplementedInterfaceClasses(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            //Debug.WriteLine(syntaxNode.GetType().Name + ": " + syntaxNode.ToString());

            if (syntaxNode is ClassDeclarationSyntax cds)
            {
                return true;
            }
            return false;
        }

        private Dictionary<ITypeSymbol, ITypeSymbol>? GetImplementedInterface(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            if (interfaceClassImplementationMappings == null)
            {
                // collect all referenced implementations
                interfaceClassImplementationMappings = new Dictionary<ITypeSymbol, ITypeSymbol>(SymbolEqualityComparer.Default);
                differentImplementationAssemblyNames = new List<string>();

                // ? caching dictionary did not work in larger solutions (executed multiple times in different context?) - no better way of collecting referenced interface implementations found yet


                var assemblyName = context.SemanticModel.Compilation.AssemblyName;
                if (assemblyName != null)
                {
#if DEBUG
                    LogToFileHelper.WriteLog($"Referenced Assemblies Scan Root: {assemblyName}");
#endif

                    assemblyName = GetMainNamespace(assemblyName);
                    FindAllIncludeDifferentAssemblyMethodCalls(context);

                    var customTypes = context.SemanticModel.Compilation.SourceModule.ReferencedAssemblySymbols
                        .Where(ras => ras.Name.StartsWith(assemblyName) || differentImplementationAssemblyNames.Contains(ras.Name))
                        .SelectMany(a =>
                        {
                            try
                            {
#if DEBUG
                                LogToFileHelper.WriteLog($"Namespaces in {assemblyName} count: {a.NamespaceNames.Count}");
#endif

                                //var main = a.Identity.Name.Split('.').Aggregate(a.GlobalNamespace, (s, c) => s.GetNamespaceMembers().Single(m => m.Name.Equals(c)));

                                return GetAllClassTypes(a.GlobalNamespace);
                            }
                            catch (Exception exMain)
                            {
#if DEBUG
                                LogToFileHelper.WriteLog("ReferencedAssemblySymbols Exception: " + exMain.ToString());
#endif
                                return Enumerable.Empty<ITypeSymbol>();
                            }
                        }).ToArray();

                    foreach (var ct in customTypes)
                    {
                        if (ct.AllInterfaces.Any())
                        {
                            foreach (var interf in ct.AllInterfaces)
                            {
                                AddCustomMap(interf, ct, true);
                            }
                        }
                    }
#if DEBUG
                    LogToFileHelper.WriteLog($"Referenced custom type count: {customTypes.Length}; {assemblyName}");
#endif
                }
            }

            if (context.Node is ClassDeclarationSyntax cds)
            {
                // received class interface implementations
                // Use the semantic model to get the symbol for this type
                var typeNodeSymbol = context.SemanticModel.Compilation
                .GetSemanticModel(cds.SyntaxTree)
                .GetDeclaredSymbol(cds);

                if (typeNodeSymbol != null)
                {
                    var typeInfo = (ITypeSymbol)typeNodeSymbol;

                    if (typeInfo.IsAbstract == false
                        && typeInfo.AllInterfaces.Any())
                    {
                        foreach (var implInterf in typeInfo.AllInterfaces)
                        {
                            AddCustomMap(implInterf, typeInfo, false);
                        }
                    }
                }
            }

            return interfaceClassImplementationMappings;
        }

        private void FindAllIncludeDifferentAssemblyMethodCalls(GeneratorSyntaxContext context)
        {
            foreach (var ti in context.SemanticModel.Compilation.SyntaxTrees)
            {
                SyntaxNode syntaxNode;
                if (ti.TryGetRoot(out syntaxNode))
                {
                    foreach (var cn in syntaxNode.DescendantNodes())
                    {
                        if (cn is IdentifierNameSyntax identifierNameSyntax)
                        {
                            //Debug.WriteLine(cn.ToString());

                            string? memberName = identifierNameSyntax.TryGetInferredMemberName();

                            if (memberName == MethodNameIncludeDifferentImplementationAssembly)
                            {
                                var parentDeclaration = identifierNameSyntax.Parent?.Parent;

                                if (parentDeclaration != null)
                                {
                                    var descendantNodes = parentDeclaration.DescendantNodes().ToArray();

                                    for (int i = 0; i < descendantNodes.Length; i++)
                                    {
                                        var n = descendantNodes[i];

                                        if (n.Equals(identifierNameSyntax))
                                        {
                                            // nameof syntax
                                            if (descendantNodes.Length > i + 6
                                                && descendantNodes[i + 4].ToString() == "nameof")
                                            {
                                                string differentAssemblyName = descendantNodes[i + 6].ToString();

                                                if (differentImplementationAssemblyNames.Contains(differentAssemblyName) == false)
                                                    differentImplementationAssemblyNames.Add(differentAssemblyName);

                                            }
                                            // simple string declaration syntax
                                            else if (descendantNodes.Length > i + 3
                                                && descendantNodes[i + 3] is LiteralExpressionSyntax les)
                                            {
                                                string diffAssemblyNameString = les.ToString().Trim('"');

                                                if (differentImplementationAssemblyNames.Contains(diffAssemblyNameString) == false)
                                                    differentImplementationAssemblyNames.Add(diffAssemblyNameString);
                                            }


                                            break;
                                        }
                                    }

                                }

                            }
                        }
                    }
                }
            }
        }




        //static IEnumerable<SyntaxNode> IterateSyntaxNodes(SyntaxNode root)
        //{
        //    foreach (var item in root.nodes)
        //    {

        //    }
        //}

        /// <summary>
        /// Gets the first two assembly namespace level
        /// </summary>
        /// <param name="assemblyName"></param>
        /// <returns></returns>
        private static string GetMainNamespace(string? assemblyName)
        {
            if (assemblyName is not null)
            {
                string[] namespaceParts = assemblyName.Split('.');
                if (namespaceParts.Length > 1)
                {
                    assemblyName = $"{namespaceParts[0]}.{namespaceParts[1]}";
                }
            }

            return assemblyName;
        }

        private void AddCustomMap(ITypeSymbol interfaceType, ITypeSymbol implInterf, bool onlyPublic)
        {
            if (interfaceType.ContainingNamespace != null)
            {
                string namespaceStr = interfaceType.ContainingNamespace.ToString();
                bool isIgnoreNamespace = namespaceStr.StartsWith("System") || namespaceStr.StartsWith("Microsoft");
                if (isIgnoreNamespace == false)
                {
                    if (implInterf.DeclaredAccessibility == Accessibility.Public
                        || (onlyPublic == false && implInterf.DeclaredAccessibility == Accessibility.Internal))
                    {

                        interfaceClassImplementationMappings[interfaceType] = implInterf;

#if DEBUG
                        LogToFileHelper.WriteLog($"Add custom map: {interfaceType} = {implInterf}");
#endif
                    }
                }
            }
        }

        private static IEnumerable<ITypeSymbol> GetAllClassTypes(INamespaceSymbol root)
        {
            int count = 0;
            int countNested = 0;

            foreach (var namespaceOrTypeSymbol in root.GetMembers())
            {
                if (namespaceOrTypeSymbol is INamespaceSymbol @namespace)
                {
                    foreach (var nested in GetAllClassTypes(@namespace))
                    {
                        countNested++;
                        yield return nested;
                    }
                }
                else if (namespaceOrTypeSymbol is ITypeSymbol type
                    && type.IsAbstract == false
                    && type.TypeKind == TypeKind.Class)
                {
                    count++;
                    yield return type;
                }
            }

#if DEBUG
            LogToFileHelper.WriteLog($"GetAllClassTypes for: {root.ToDisplayString()}; count: {count}; nested count: {countNested}");
#endif
        }


        //private void ExecuteGenerateCode(SourceProductionContext context, ((ImmutableArray<ITypeSymbol> proxyInterfaceTypes, string? assemblyName) input1, ImmutableArray<Dictionary<ITypeSymbol, ITypeSymbol>?> implementations) input)
        //private void ExecuteGenerateCode(SourceProductionContext context, (((ImmutableArray<ITypeSymbol> proxyInterfaceTypes, string? assemblyName) proxyInterfaceAssembly, ImmutableArray<Dictionary<ITypeSymbol, ITypeSymbol>?> implementations) proxyImpl, ImmutableArray<ITypeSymbol> localSessionInterfaceTypes) input)
        private void ExecuteGenerateCode(SourceProductionContext context, ((((ImmutableArray<ITypeSymbol> proxyInterfaceTypes, string? assemblyName) proxyInterfaceAssembly, ImmutableArray<Dictionary<ITypeSymbol, ITypeSymbol>?> implementations) proxyImpl, ImmutableArray<ITypeSymbol> localSessionInterfaceTypes) combined, ImmutableArray<bool> enabledIndicator) input)
        {
            bool isCodegenerationEnabled = input.enabledIndicator != null
                                            && input.enabledIndicator.Length > 0
                                            && input.enabledIndicator.All(ei => ei == true);
#if DEBUG
            LogToFileHelper.WriteLog($"isCodegenerationEnabled: {isCodegenerationEnabled}");
#endif
            //if (input.combined.proxyImpl.proxyInterfaceAssembly.proxyInterfaceTypes.IsDefaultOrEmpty
            //    && input.combined.localSessionInterfaceTypes.IsDefaultOrEmpty)
            //    return;

            string containingNamespace = input.combined.proxyImpl.proxyInterfaceAssembly.assemblyName;
            List<string> proxyInterfaceClassNames = new List<string>(input.combined.proxyImpl.proxyInterfaceAssembly.proxyInterfaceTypes.Length);
            List<ITypeSymbol> allDtoTypes = new List<ITypeSymbol>();
            List<string> allDtoImplementationNames = new List<string>();
            Dictionary<ITypeSymbol, ITypeSymbol> customInterfaceImplementations = new Dictionary<ITypeSymbol, ITypeSymbol>();

            if (isCodegenerationEnabled)
            {
                var allInterfaceImplementations = input.combined.proxyImpl.implementations.FirstOrDefault();

#if DEBUG
                LogToFileHelper.WriteLog($"implementations dictionary count: {input.combined.proxyImpl.implementations.Length}; first count: {allInterfaceImplementations.Count}");
#endif

                // remove duplicates
                input.combined.proxyImpl.proxyInterfaceAssembly.proxyInterfaceTypes = input.combined.proxyImpl.proxyInterfaceAssembly.proxyInterfaceTypes.Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>().ToImmutableArray();
                foreach (var type in input.combined.proxyImpl.proxyInterfaceAssembly.proxyInterfaceTypes)
                {
                    context.CancellationToken.ThrowIfCancellationRequested();

                    string code = BuildProxyImplementationSource(type, out var dtoTypes, out string proxyClassName).ToString();
                    proxyInterfaceClassNames.Add(proxyClassName);


                    var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                           ? null
                           : $"{type.ContainingNamespace}.";

                    context.AddSource($"{typeNamespace}{type.Name}AutoGenProxy.g.cs", code);


                    foreach (var dtoType in dtoTypes)
                    {
                        if (allDtoTypes.Contains(dtoType) == false)
                            allDtoTypes.Add(dtoType);
                    }
                }


                // collect local session dto mappings
                // only nested types are collected because registration with class implmentation mapping is expected
                foreach (var localSessionServiceInterface in input.combined.localSessionInterfaceTypes.Distinct(SymbolEqualityComparer.Default)
                                                 .Cast<ITypeSymbol>())
                {
                    context.CancellationToken.ThrowIfCancellationRequested();

                    //Debug.WriteLine($"{localSessionServiceInterface}");

                    GetDtoTypesByForMembersRecursive(localSessionServiceInterface, allDtoTypes);
                }


                // create data transfer object implementations (implementation not found anywhere?)
                for (int dtoIndex = 0; dtoIndex < allDtoTypes.Count; dtoIndex++)
                {
                    var dtoInterfType = allDtoTypes[dtoIndex];

                    // check for nested interfaces
                    foreach (var member in dtoInterfType.GetMembers())
                    {
                        if (member is IPropertySymbol pi)
                            CheckForNestedDtoTypes(pi, allDtoTypes, $"member of {dtoInterfType}");
                    }

                    if (allInterfaceImplementations != null
                        && allInterfaceImplementations.TryGetValue(dtoInterfType, out ITypeSymbol actualImplType))
                    {
                        // do not auto implement already custom implemented interface
                        allDtoTypes.RemoveAt(dtoIndex);
                        dtoIndex--;

                        // add to custom implmentation mapping
                        customInterfaceImplementations[dtoInterfType] = actualImplType;

//#if DEBUG
//                        LogToFileHelper.WriteLog($"Use custom map: {dtoInterfType} = {actualImplType}");
//#endif

                        // skip dto implmentation
                        continue;
                    }


                    string dtoSource = CreateDtoImplementationSource(dtoInterfType, containingNamespace, allDtoTypes, out string className).ToString();
                    allDtoImplementationNames.Add(className);

                    var typeNamespace = dtoInterfType.ContainingNamespace.IsGlobalNamespace
                                       ? null
                                       : $"{dtoInterfType.ContainingNamespace}.";

                    context.AddSource($"{typeNamespace}{GetImplName(dtoInterfType.Name)}AutoGenDto.g.cs", dtoSource);
                }
            }
            // else: only generate method declaration for futher use

            // Build interface implementation helper class
            if (containingNamespace != null)
            {
                string mappingSource;
                if (isCodegenerationEnabled)
                    mappingSource = BuildInterfaceImplementationMappingsSource(input.combined.proxyImpl.proxyInterfaceAssembly.proxyInterfaceTypes, containingNamespace, proxyInterfaceClassNames, allDtoTypes, allDtoImplementationNames, customInterfaceImplementations).ToString();
                else
                    mappingSource = BuildEmptyRegistrationMappingsSource(containingNamespace).ToString();

#if DEBUG
                mappingSource += Environment.NewLine + "// Debug Source Gen Logging:" + Environment.NewLine;
                mappingSource += LogToFileHelper.GetLogsCodeText();
#endif

                context.AddSource($"AutoGeneratedInterfaceImplementationMapping.g.cs", mappingSource);
            }

        }


        private StringBuilder BuildInterfaceImplementationMappingsSource(ImmutableArray<ITypeSymbol> proxyInterfaceTypes, string assemblyName, List<string> proxyClassNames, List<ITypeSymbol> dtoTypes, List<string> dtoImplementationNames, Dictionary<ITypeSymbol, ITypeSymbol>? interfImplementations)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("using BSAG.IOCTalk.Common.Interface.Container;");
            sb.AppendLine("using BSAG.IOCTalk.Composition;");
            sb.AppendLine();
            sb.Append("namespace ");
            sb.AppendLine(assemblyName);
            sb.AppendLine("{");
            sb.AppendLine();

            sb.AppendLine($"// Auto generated by {GetType().FullName} version {GetType().Assembly.GetName().Version} at {DateTime.Now}");


            sb.AppendLine("internal static class AutoGeneratedProxyInterfaceImplementations { ");

            sb.AppendLine("     public static FluentAutoGenApi RegisterAutoGeneratedProxyInterfaceMappings(this TalkCompositionHost ctx)");
            sb.AppendLine("     {");

            sb.AppendLine($"         // custom interface implementations (includes all assemblies starting with \"{GetMainNamespace(assemblyName)}*\" or explicit by RegisterAutoGeneratedProxyInterfaceMappings().IncludeDifferentImplementationAssembly(nameof(x)))");
            if (interfImplementations != null && interfImplementations.Any())
            {
                foreach (var customImpl in interfImplementations)
                {
                    if (proxyInterfaceTypes.Contains(customImpl.Key))
                    {
#if DEBUG
                        LogToFileHelper.WriteLog($"Do not map custom proxy interface implementation: {customImpl.Key} / {customImpl.Value}");
#endif
                        continue;   // do not map proxy interface
                    }

                    sb.AppendLine($"         ctx.MapInterfaceImplementationType<{customImpl.Key}, {customImpl.Value}>();");
                }
                sb.AppendLine();
            }
            else
                sb.AppendLine("         // No custom implementations found");


            if (proxyInterfaceTypes.Length > 0)
            {
                sb.AppendLine("         // remote proxy mappings");

                for (int i = 0; i < proxyInterfaceTypes.Length; i++)
                {
                    var proxyInterfType = proxyInterfaceTypes[i];
                    var proxyImplType = proxyClassNames[i];

                    sb.AppendLine($"         ctx.MapInterfaceImplementationType<{proxyInterfType}, {proxyInterfType.ContainingNamespace}.{proxyImplType}>();");
                }
            }

            sb.AppendLine();

            if (dtoTypes.Count > 0)
            {
                sb.AppendLine("         // DTO mappings");
                for (int i = 0; i < dtoTypes.Count; i++)
                {
                    var interfaceType = dtoTypes[i];
                    var implementationType = dtoImplementationNames[i];

                    sb.AppendLine($"         ctx.MapInterfaceImplementationType<{interfaceType}, {assemblyName}.{implementationType}>();");
                }
            }

            sb.AppendLine("     return new FluentAutoGenApi();");

            sb.AppendLine("     }");


            sb.AppendLine(" }");

            // fluent API - start
            sb.AppendLine();
            sb.AppendLine(" internal class FluentAutoGenApi");
            sb.AppendLine(" {");
            sb.AppendLine("     public FluentAutoGenApi IncludeDifferentImplementationAssembly(string assemblyName)");
            sb.AppendLine("     {");
            sb.AppendLine("         return this;    // no implementation - only used by code generator");
            sb.AppendLine("     }");
            sb.AppendLine(" }");
            sb.AppendLine();
            // fluent API - end

            sb.AppendLine("}");

            return sb;
        }


        private StringBuilder BuildEmptyRegistrationMappingsSource(string assemblyName)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("/*using BSAG.IOCTalk.Common.Interface.Container;");
            sb.AppendLine("using BSAG.IOCTalk.Composition;");
            sb.AppendLine();
            sb.Append("namespace ");
            sb.AppendLine(assemblyName);
            sb.AppendLine("{");

            sb.AppendLine("internal static class AutoGeneratedProxyInterfaceImplementations { ");

            sb.AppendLine("     public static void RegisterAutoGeneratedProxyInterfaceMappings(this TalkCompositionHost ctx)");
            sb.AppendLine("     {");
            sb.AppendLine($"         // Empty method body because BSAG.IOCTalk.Composition use was not found in assembly: {assemblyName}");
            sb.AppendLine($"         // Add ioctalk TalkCompositionHost container registration to activate auto code generation.");
            sb.AppendLine("     }");

            sb.AppendLine(" }");
            sb.AppendLine("}*/");

            return sb;
        }


        public static StringBuilder BuildProxyImplementationSource(ITypeSymbol interfaceType, out List<ITypeSymbol> dtoTypes, out string className)
        {
            if (!interfaceType.IsAbstract)
                throw new Exception("Type must be an interface!");

            className = GetImplName(interfaceType.Name) + "AutoGenProxy";

            StringBuilder source = new StringBuilder();

            source.AppendLine("using System;");
            source.AppendLine("using BSAG.IOCTalk.Common.Reflection;");
            source.AppendLine("using BSAG.IOCTalk.Common.Interface.Reflection;");
            source.AppendLine("using BSAG.IOCTalk.Common.Interface.Session;");
            source.AppendLine("using BSAG.IOCTalk.Common.Interface.Communication;");

            source.AppendLine();
            source.Append("namespace ");
            //source.AppendLine("AutoGeneratedProxiesNamespace ");
            source.AppendLine(interfaceType.ContainingNamespace.ToString());
            source.AppendLine("{");
            source.Append($" internal class {className} : {interfaceType.ContainingNamespace}.{interfaceType.Name}, ISessionContext");
            source.AppendLine(" {");
            dtoTypes = new List<ITypeSymbol>();
            var methodInfoMemberNames = CreateProxyInterfaceMethodSourceCode(source, interfaceType, dtoTypes);

            // add communication service field
            source.AppendLine();
            //source.Append("     ");
            source.AppendLine("     private IGenericCommunicationService communicationService;");
            source.AppendLine("     private ISession session;");
            source.AppendLine();

            // add constructor
            source.AppendLine($"    public {className}(IGenericCommunicationService commService, ISession session)");
            source.AppendLine("     {");
            source.AppendLine("         this.communicationService = commService;");
            source.AppendLine("         this.session = session;");

            //todo: determine runtime async invoke state for each method

            source.AppendLine("     }");

            source.AppendLine("     public IGenericCommunicationService CommunicationService => communicationService;");
            source.AppendLine("     public ISession Session => session;");

            source.AppendLine(" }");
            source.AppendLine("}");
            return source;
        }

        private static List<string> CreateProxyInterfaceMethodSourceCode(StringBuilder mainSource, ITypeSymbol interfaceType, List<ITypeSymbol> dtoItems)
        {
            List<string> methodInfoMemberNames = new List<string>();
            HashSet<string> methodSignatureNames = new HashSet<string>();


            CreateProxyInterfaceMethodForTyp(mainSource, interfaceType, dtoItems, methodInfoMemberNames, methodSignatureNames);

            foreach (var baseInterface in interfaceType.AllInterfaces)
            {
                CreateProxyInterfaceMethodForTyp(mainSource, baseInterface, dtoItems, methodInfoMemberNames, methodSignatureNames);
            }

            return methodInfoMemberNames;
        }

        private static void CreateProxyInterfaceMethodForTyp(StringBuilder mainSource, ITypeSymbol interfaceType, List<ITypeSymbol> dtoItems, List<string> methodInfoMemberNames, HashSet<string> methodSignatureNames)
        {
            foreach (var member in interfaceType.GetMembers())
            {
                if (member is IMethodSymbol method)
                    CreateProxyInterfaceMemberMethod(mainSource, interfaceType, dtoItems, methodInfoMemberNames, method, methodSignatureNames);
            }
        }

        private static void CreateProxyInterfaceMemberMethod(StringBuilder mainSource, ITypeSymbol interfaceType, List<ITypeSymbol> dtoItems, List<string> methodInfoMemberNames, IMethodSymbol method, HashSet<string> methodSignatureNames)
        {
            string methodSignatureName = $"{method.Name}-{string.Join(",", method.Parameters.Select(p => p.Type.ToString()))}";
            if (methodSignatureNames.Contains(methodSignatureName) == false)        // for base interfaces do not add twice a method
            {
                methodSignatureNames.Add(methodSignatureName);

                string methodBodyIntention = "\t\t";
                string methodLineIntention = "\t\t\t";


                StringBuilder sbInvokeInfoMember = new StringBuilder();
                sbInvokeInfoMember.AppendLine();

                StringBuilder methodSource = new StringBuilder();

                ////test
                //methodSource.AppendLine($"// {methodSignatureName} ({method})");

                bool isReturnRequired;
                string returnType;
                bool isAsyncAwait = false;
                bool containsAsyncResultValue = false;
                if (method.ReturnsVoid)
                {
                    isReturnRequired = false;
                    returnType = "void";
                }
                else
                {
                    isReturnRequired = true;
                    isAsyncAwait = IsAsyncAwaitType(method.ReturnType, out containsAsyncResultValue);
                    if (isAsyncAwait)
                    {
                        isReturnRequired = containsAsyncResultValue;

                        if (isReturnRequired)
                            AddAsyncMethodReturnDtoItems(dtoItems, method);
                    }
                    else
                        CheckAndAddDtoType(dtoItems, method.ReturnType, $"proxy method ret type: {method}");

                    returnType = GetSourceCodeTypeName(method.ReturnType);
                }

                methodSource.AppendLine();
                if (isAsyncAwait)
                {
                    methodSource.AppendFormat("{0}public async {1} {2}(", methodBodyIntention, returnType, method.Name);
                }
                else
                    methodSource.AppendFormat("{0}public {1} {2}(", methodBodyIntention, returnType, method.Name);

                string invokeInfoMemberName = string.Format("methodInfo{0}_", method.Name);

                List<IParameterSymbol>? outParameters = null;
                StringBuilder? sbParameterValues = null;
                StringBuilder? sbParameterTypes = null;

                var parameters = method.Parameters;

                sbParameterTypes = new StringBuilder();
                sbParameterTypes.Append("new Type[] { ");

                if (parameters.Length > 0)
                {
                    sbParameterValues = new StringBuilder();
                    sbParameterValues.Append(methodLineIntention);
                    sbParameterValues.Append("object[] parameterValues = new object[] { ");

                    for (int i = 0; i < parameters.Length; i++)
                    {
                        var param = parameters[i];

                        ITypeSymbol paramType = param.Type;
                        string? decoration = null;
                        //if (param.IsOut)
                        if (param.RefKind == RefKind.Out)
                        {
                            decoration = "out";
                            //paramType = paramType.GetElementType();

                            if (outParameters == null)
                                outParameters = new List<IParameterSymbol>();

                            outParameters.Add(param);
                        }

                        string parameterTypeString = GetSourceCodeTypeName(paramType);

                        methodSource.AppendFormat("{0} {1} {2}", decoration, parameterTypeString, param.Name);

                        string invokeInfoMemberTypeName = string.Concat(decoration, parameterTypeString);
                        invokeInfoMemberTypeName = Regex.Replace(invokeInfoMemberTypeName, @"[^a-zA-Z0-9]", "");    // remove invalid chars

                        if (paramType is IArrayTypeSymbol)
                            invokeInfoMemberTypeName += "Arr";

                        invokeInfoMemberName += invokeInfoMemberTypeName;

                        // add reference to parameter value array
                        if (param.RefKind == RefKind.Out)
                        {
                            // out parameter -> pass null
                            sbParameterValues.Append("null");
                        }
                        else
                        {
                            sbParameterValues.Append(param.Name);
                        }

                        // type array
                        sbParameterTypes.AppendFormat("typeof({0}){1}", parameterTypeString, (param.RefKind == RefKind.Out ? ".MakeByRefType()" : null));


                        if (i < parameters.Length - 1)
                        {
                            methodSource.Append(", ");
                            sbParameterValues.Append(", ");
                            sbParameterTypes.Append(", ");
                        }

                        CheckAndAddDtoType(dtoItems, param.Type, $"proxy method params: {method}");
                    }

                    sbParameterValues.AppendLine(" };");

                }


                sbParameterTypes.Append(" } ");

                methodSource.AppendLine(")");

                methodSource.Append(methodBodyIntention);
                methodSource.AppendLine("{");

                if (sbParameterValues != null)
                {
                    methodSource.Append(sbParameterValues);
                }

                sbInvokeInfoMember.Append(methodBodyIntention);
                string iTypeFullStr = $"{interfaceType.ContainingNamespace}.{interfaceType.Name}";
                sbInvokeInfoMember.AppendFormat("private static IInvokeMethodInfo {0} = new InvokeMethodInfo(typeof({1}), \"{2}\", {3});", invokeInfoMemberName, iTypeFullStr, method.Name, sbParameterTypes.ToString());
                sbInvokeInfoMember.AppendLine();

                methodSource.Append(methodLineIntention);

                if (isReturnRequired)
                    methodSource.Append("object result = ");

                if (isAsyncAwait)
                    methodSource.AppendFormat("await communicationService.InvokeMethodAsync(this, {0}, session, {1});", invokeInfoMemberName, (sbParameterValues != null ? "parameterValues" : "null"));
                else
                    methodSource.AppendFormat("communicationService.InvokeMethod(this, {0}, session, {1});", invokeInfoMemberName, (sbParameterValues != null ? "parameterValues" : "null"));

                methodSource.AppendLine();

                if (outParameters != null)
                {
                    // assign out parameters

                    for (int outParamIndex = 0; outParamIndex < outParameters.Count; outParamIndex++)
                    {
                        var outParam = outParameters[outParamIndex];
                        methodSource.AppendFormat("{0}{1} = ({2})parameterValues[{3}];", methodLineIntention, outParam.Name, GetSourceCodeTypeName(outParam.Type), outParamIndex);
                        methodSource.AppendLine();
                    }
                }

                if (isReturnRequired)
                {
                    if (isAsyncAwait)
                    {
                        if (containsAsyncResultValue)
                        {
                            string genericTypeStr = GetSourceCodeTypeName(((INamedTypeSymbol)method.ReturnType).TypeArguments.First());

                            methodSource.Append($"{methodLineIntention}return ({genericTypeStr})result;");
                        }
                        // else: Task/ValueTask void return
                    }
                    else
                        methodSource.AppendFormat("{0}return ({1})result;", methodLineIntention, returnType);

                    methodSource.AppendLine();
                }

                methodSource.Append(methodBodyIntention);
                methodSource.AppendLine("}");
                methodSource.AppendLine();

                // add to main source
                mainSource.Append(sbInvokeInfoMember);
                mainSource.Append(methodSource);

                methodInfoMemberNames.Add(invokeInfoMemberName);
            }
            //else
            //    mainSource.AppendLine($"// Ignore already added method creation {methodSignatureName} ({method})");
        }

        private static StringBuilder CreateDtoImplementationSource(ITypeSymbol interfaceType, string containingNamespace, List<ITypeSymbol> dtoTypes, out string className, ITypeSymbol? parentType = null)
        {
            //string assemblyName = $"IOCTalk.AutoGeneratedAssembly{interfaceType.Name}";

            StringBuilder code = new StringBuilder();
            code.AppendLine("using System;");
            code.AppendLine();
            code.Append("namespace ");
            //code.Append(assemblyName);
            //code.AppendLine(interfaceType.ContainingNamespace.ToString());
            code.AppendLine(containingNamespace);
            code.AppendLine();
            code.AppendLine("{");
            className = $"{GetImplName(interfaceType.Name)}AutoGenDto";
            code.Append($"   internal class {className}");
            code.Append(" : ");
            if (parentType != null)
            {
                code.Append(GetSourceCodeTypeName(parentType));
                code.Append(", ");
                code.Append(GetSourceCodeTypeName(interfaceType));
            }
            else
            {
                code.Append(GetSourceCodeTypeName(interfaceType));
            }
            code.AppendLine();
            code.AppendLine("   {");
            code.AppendLine();
            // implement get/set properties
            foreach (var member in interfaceType.GetMembers())
            {
                if (member is IPropertySymbol pi)
                    AddPropertyCode(code, pi, dtoTypes);
                else if (member is IMethodSymbol method
                    && method.AssociatedSymbol is not IPropertySymbol)
                {
                    // Methods in transfer objects are not supported!
                    // Add dummy method with NotSupportedException to fulfil interface contract
                    AddDummyTransferInterfaceMethodNotSupportedImplementation(code, method);
                }
                else
                {
#if DEBUG
                    LogToFileHelper.WriteLog($"Warning: Ignore unsupported {interfaceType} interface member in DTO: {member}; Type: {member.Kind}");
#endif
                }
            }

            // implement base interface properties
            foreach (var baseInterface in interfaceType.Interfaces)
            {
                foreach (var baseMember in baseInterface.GetMembers())
                {
                    if (baseMember is IPropertySymbol piBase)
                        AddPropertyCode(code, piBase, dtoTypes);
                    else if (baseMember is IMethodSymbol method
                            && method.AssociatedSymbol is not IPropertySymbol)
                    {
                        // Methods in transfer objects are not supported!
                        // Add dummy method with NotSupportedException to fulfil interface contract
                        AddDummyTransferInterfaceMethodNotSupportedImplementation(code, method);
                    }
                    else
                    {
#if DEBUG
                        LogToFileHelper.WriteLog($"Warning: Ignore unsupported {baseInterface} base interface member in DTO: {baseMember}; Type: {baseMember.Kind}");
#endif
                    }
                }
            }

            code.AppendLine();
            code.AppendLine("   }");
            code.AppendLine("}");

            return code;
        }

        private static void AddDummyTransferInterfaceMethodNotSupportedImplementation(StringBuilder code, IMethodSymbol method)
        {
            string methodBodyIntention = "      ";
            bool isReturnRequired;
            string returnType;
            bool isAsyncAwait = false;
            bool containsAsyncResultValue = false;
            if (method.ReturnsVoid)
            {
                isReturnRequired = false;
                returnType = "void";
            }
            else
            {
                isReturnRequired = true;
                isAsyncAwait = IsAsyncAwaitType(method.ReturnType, out containsAsyncResultValue);
                if (isAsyncAwait)
                {
                    isReturnRequired = containsAsyncResultValue;

                    //if (isReturnRequired)
                    //    AddAsyncMethodReturnDtoItems(dtoItems, method);
                }
                //else
                //    CheckAndAddDtoType(dtoItems, method.ReturnType, $"proxy method ret type: {method}");

                returnType = GetSourceCodeTypeName(method.ReturnType);
            }

            code.AppendLine();
            if (isAsyncAwait)
            {
                code.AppendFormat("{0}public async {1} {2}(", methodBodyIntention, returnType, method.Name);
            }
            else
                code.AppendFormat("{0}public {1} {2}(", methodBodyIntention, returnType, method.Name);


            List<IParameterSymbol>? outParameters = null;

            var parameters = method.Parameters;

            if (parameters.Length > 0)
            {

                for (int i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];

                    ITypeSymbol paramType = param.Type;
                    string? decoration = null;
                    //if (param.IsOut)
                    if (param.RefKind == RefKind.Out)
                    {
                        decoration = "out";
                        //paramType = paramType.GetElementType();

                        if (outParameters == null)
                            outParameters = new List<IParameterSymbol>();

                        outParameters.Add(param);
                    }

                    string parameterTypeString = GetSourceCodeTypeName(paramType);

                    code.AppendFormat("{0} {1} {2}", decoration, parameterTypeString, param.Name);

                    if (i < parameters.Length - 1)
                    {
                        code.Append(", ");
                    }
                }
            }

            code.AppendLine(")");

            code.Append(methodBodyIntention);
            code.AppendLine("{");

            code.Append(methodBodyIntention);
            code.Append(methodBodyIntention);
            code.AppendLine("throw new NotSupportedException(\"Auto generated data transfer objects do not support method implementations! Add a custom interface implementation on client side, remove method from nested proxy method parameter interface or move method to parent proxy implementation.\");");

            code.Append(methodBodyIntention);
            code.AppendLine("}");
        }

        private static void AddPropertyCode(StringBuilder code, IPropertySymbol pi, List<ITypeSymbol> dtoTypes)
        {
            //if (pi.SetMethod == null)
            //    code.AppendLine($"      public {GetSourceCodeTypeName(pi.Type)} {pi.Name} {{get {{ throw new NotSupportedException(\"Auto generated only get properties are not supported in transfer only interfaces! Add a custom interface implementation on client side or add property setter to solve this.\") }} }}");
            //else
            code.AppendLine($"      public {GetSourceCodeTypeName(pi.Type)} {pi.Name} {{get; set;}}");
            code.AppendLine();

            CheckForNestedDtoTypes(pi, dtoTypes, $"DTO prop {pi.Type} / {pi.ContainingType}");
        }

        private static void GetDtoTypesByForMembersRecursive(ITypeSymbol interfaceType, List<ITypeSymbol> dtoItems)
        {
            if (interfaceType.TypeKind == TypeKind.Interface)
            {
                foreach (var member in interfaceType.GetMembers())
                {
                    if (member is IPropertySymbol pi)
                    {
                        CheckForNestedDtoTypes(pi, dtoItems, $"interface prop child: {interfaceType}");
                    }
                    else if (member is IMethodSymbol method)
                    {
                        if (method.AssociatedSymbol is IPropertySymbol piBase)
                        {
                            CheckForNestedDtoTypes(piBase, dtoItems, $"method AssociatedSymbol {interfaceType} / {piBase}");
                        }
                        else
                        {
                            if (method.ReturnsVoid == false)
                            {
                                if (IsAsyncAwaitType(method.ReturnType, out bool containsAsyncResultValue))
                                {
                                    if (containsAsyncResultValue)
                                    {
                                        AddAsyncMethodReturnDtoItems(dtoItems, method);
                                    }
                                }
                                else
                                    CheckAndAddDtoType(dtoItems, method.ReturnType, $"method ret. type: {method}; associated: {method.AssociatedSymbol} {method.AssociatedSymbol?.Kind}");
                            }

                            if (method.Parameters.Length > 0)
                            {
                                foreach (var param in method.Parameters)
                                {
                                    CheckAndAddDtoType(dtoItems, param.Type, $"method param: {method}");
                                }
                            }
                        }
                    }
#if DEBUG
                    else
                    {
                        LogToFileHelper.WriteLog($"Skip recursive member check: {member}; Interface type: {interfaceType}");
                    }
#endif

                }

                foreach (var baseInterface in interfaceType.Interfaces)
                {
                    foreach (var baseMember in baseInterface.GetMembers())
                    {
                        if (baseMember is IPropertySymbol piBase)
                            CheckForNestedDtoTypes(piBase, dtoItems, $"base prop {baseMember} / {baseInterface}");
                    }
                }
            }
        }

        private static void AddAsyncMethodReturnDtoItems(List<ITypeSymbol> dtoItems, IMethodSymbol method)
        {
            foreach (var genericArgType in ((INamedTypeSymbol)method.ReturnType).TypeArguments)
            {
                CheckAndAddDtoType(dtoItems, genericArgType, $"method ret. type arg: {method}");
            }
        }

        private static void CheckAndAddDtoType(List<ITypeSymbol> dtoItems, ITypeSymbol dtoType, string parentInfo)
        {
            if (dtoType.TypeKind == TypeKind.Interface)
            {
                if (dtoType is INamedTypeSymbol nts)
                {
                    if (nts.IsGenericType == false)         // do not auto implement generic types (IList<T>, IEnumerable<T> ...); todo: check custom generic interface implementation?
                        AddDtoType(dtoItems, dtoType, parentInfo);
                    else
                    {
                        // only one generic arg supported yet
                        var genericTypeArg0 = nts.TypeArguments.FirstOrDefault();

                        if (genericTypeArg0 != null)
                        {
                            CheckAndAddDtoType(dtoItems, genericTypeArg0, parentInfo);
                        }
                    }
                }
                else
                    AddDtoType(dtoItems, dtoType, parentInfo);
            }
            else if (dtoType.TypeKind == TypeKind.Array)
            {
                var arrType = (IArrayTypeSymbol)dtoType;

                if (arrType.ElementType.TypeKind == TypeKind.Interface)
                {
                    AddDtoType(dtoItems, arrType.ElementType, parentInfo);
                }
            }
        }

        private static void AddDtoType(List<ITypeSymbol> dtoItems, ITypeSymbol dtoType, string parentInfo)
        {
            if (dtoItems.Contains(dtoType) == false)
            {
#if DEBUG
                LogToFileHelper.WriteLog($"Add interf. DTO type: {dtoType.Name}; Parent: {parentInfo}");
#endif
                dtoItems.Add(dtoType);

                GetDtoTypesByForMembersRecursive(dtoType, dtoItems);
            }
        }

        private static void CheckForNestedDtoTypes(IPropertySymbol pi, List<ITypeSymbol> dtoTypes, string parentInfo)
        {
            if ((pi.Type.IsAbstract || pi.Type.Kind == SymbolKind.ArrayType)
                && pi.Type.IsReferenceType
                && pi.GetMethod != null
                && pi.SetMethod != null)    // only if get/set property (DTO)
            {
                CheckAndAddDtoType(dtoTypes, pi.Type, parentInfo);
            }
#if DEBUG
            else
            {
                LogToFileHelper.WriteLog($"Ignore property check: {pi}; IsAbstract: {pi.Type.IsAbstract}; IsReferenceType: {pi.Type.IsReferenceType}; Get: {pi.GetMethod != null}; Set: {pi.SetMethod != null}; Parent: {parentInfo}");
            }
#endif
        }

        private static string GetSourceCodeTypeName(ITypeSymbol type)
        {
            if (type is IArrayTypeSymbol arrayType)
            {
                return $"{GetSourceNamespace(arrayType.ElementType.ContainingNamespace)}{arrayType.ElementType.Name}[]";
            }
            else if (type is INamedTypeSymbol nts
                && nts.IsGenericType)
            {
                return $"{GetSourceNamespace(type.ContainingNamespace)}{type.Name}<{string.Join(", ", nts.TypeArguments.Select(ta => GetSourceCodeTypeName(ta)))}>";
            }
            else
                return $"{GetSourceNamespace(type.ContainingNamespace)}{type.Name}";
        }

        private static string GetSourceNamespace(INamespaceSymbol namespaceSymbol)
        {
            if (namespaceSymbol.Name == "System" || namespaceSymbol.IsGlobalNamespace)
                return string.Empty;
            else
                return $"{namespaceSymbol}.";
        }

        private static string GetImplName(string interfaceName)
        {
            if (interfaceName.StartsWith("I"))
            {
                return interfaceName.Substring(1);
            }
            else
            {
                return interfaceName;
            }
        }


        /// <summary>
        /// Determines if the given type is an async await Task like type
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool IsAsyncAwaitType(ITypeSymbol type, out bool containsResultValue)
        {

            bool isAsyncAwait = type.AllInterfaces.Where(nts => nts.Name == "IAsyncResult" && nts.ContainingNamespace.Name == "System").Any();

            if (isAsyncAwait)
            {
                bool isGenericType = ((INamedTypeSymbol)type).IsGenericType;

                containsResultValue = isGenericType;
            }
            else
                containsResultValue = false;

            return isAsyncAwait;
        }

    }
}
