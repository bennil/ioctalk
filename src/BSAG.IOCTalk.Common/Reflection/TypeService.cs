using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using System.Collections;
using Microsoft.CSharp;
using System.CodeDom.Compiler;
using System.Text.RegularExpressions;
using System.Linq.Expressions;
#if !AheadOfTimeOnly
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
#endif
using System.IO;

namespace BSAG.IOCTalk.Common.Reflection
{
    /// <summary>
    /// Reflection type service
    /// </summary>
    public static class TypeService
    {
        /// <summary>
        /// Auto generated proxy namespace
        /// </summary>
        public const string AutoGeneratedProxiesNamespace = "IOCTalk.AutoGeneratedProxies";

        private static string autoGeneratedDllName = "IOCTalkAutoGenerated.dll";

        private static readonly char[] GenericTypeChars = new char[] { '`', '<' };

        private static Dictionary<Type, Func<object>> constructorDelegateCache = new Dictionary<Type, Func<object>>();
        private static Dictionary<Type, ConstructorParamsCache> constructorDelegateCacheParams = new Dictionary<Type, ConstructorParamsCache>();
        private static object syncObj = new object();

#if AheadOfTimeOnly

        /// <summary>
        /// Builds the type of the interface implementation.
        /// </summary>
        /// <param name="interfaceTypeFullname">The interface type fullname.</param>
        /// <param name="isAssemblyDebuggable">if set to <c>true</c> is auto generated assembly debuggable.</param>
        /// <returns></returns>
        public static Type BuildInterfaceImplementationType(string interfaceTypeFullname)
        {
            throw new NotSupportedException($"This IOCTalk.Common version is compiled with ahead of time only. This means you must provide a local implementation for the interface {interfaceTypeFullname}. If your platform supports roslyn runtime compilation you can switch to the full version.");
        }
#else

        /// <summary>
        /// Builds the type of the interface implementation.
        /// </summary>
        /// <param name="interfaceTypeFullname">The interface type fullname.</param>
        /// <param name="isAssemblyDebuggable">if set to <c>true</c> is auto generated assembly debuggable.</param>
        /// <returns></returns>
        public static Type BuildInterfaceImplementationType(string interfaceTypeFullname)
        {
            try
            {
                Type implementationType = null;
                // lookup interface type
                Type interfaceType;
                if (TryGetTypeByName(interfaceTypeFullname, out interfaceType))
                {
                    if (interfaceType.GetInterface(typeof(IEnumerable).FullName) != null)
                    {
                        // type is a collection
                        // check if collection is generic IEnumerable<T>
                        Type enumerableClassType = null;
                        Type genericCollectionInterface = interfaceType.GetInterface("IEnumerable`1");
                        if (interfaceType.IsGenericType
                            || genericCollectionInterface != null)
                        {
                            Type[] genericTypes = interfaceType.GetGenericArguments();
                            if (genericTypes.Length == 1)
                            {
                                Type listType = typeof(List<>);
                                enumerableClassType = listType.MakeGenericType(genericTypes);
                            }
                            else if (genericTypes.Length == 0
                                && genericCollectionInterface != null)
                            {
                                genericTypes = genericCollectionInterface.GetGenericArguments();
                                Type listType = typeof(List<>);
                                enumerableClassType = listType.MakeGenericType(genericTypes);
                            }
                            else
                            {
                                throw new NotImplementedException("More than one generic arguments is not supported yet!");
                            }
                        }
                        else
                        {
                            // untyped collection
                            enumerableClassType = typeof(ArrayList);
                        }

                        if (interfaceType.IsAssignableFrom(enumerableClassType))
                        {
                            // enumeration has no inheritance -> return concrete collection type
                            implementationType = enumerableClassType;
                        }
                        else
                        {
                            // create collection type with parent concreate collection implementation
                            implementationType = CreateImplementation(interfaceType, enumerableClassType);
                        }
                    }
                    else
                    {
                        // create new interface implementation object
                        implementationType = CreateImplementation(interfaceType);
                    }
                }
                return implementationType;
            }
            catch (Exception e)
            {
                System.Diagnostics.Debug.WriteLine(e.ToString());
                return null;
            }

        }

        private static Type CreateImplementation(Type interfaceType)
        {
            return CreateImplementation(interfaceType, null);
        }

        private static Type CreateImplementation(Type interfaceType, Type parentType)
        {
            string assemblyName = $"IOCTalk.AutoGeneratedAssembly{interfaceType.Name}";

            StringBuilder code = new StringBuilder();
            code.AppendLine("using System;");
            code.AppendLine();
            code.Append("namespace ");
            code.Append(assemblyName);
            code.AppendLine();
            code.AppendLine("{");
            code.Append($"   public class {interfaceType.Name}AutoGenerated");
            code.Append(" : ");
            if (parentType != null)
            {
                code.Append(GetSourceCodeTypeName(parentType));
                code.Append(", ");
                code.Append(GetSourceCodeTypeName(interfaceType));
            }
            else
            {
                code.Append(interfaceType.FullName);
            }
            code.AppendLine();
            code.AppendLine("   {");
            code.AppendLine();
            // implement get/set properties
            foreach (var pi in interfaceType.GetProperties())
            {
                AddPropertyCode(code, pi);
            }

            // implement base interface properties
            Type[] baseInterfaces = interfaceType.GetInterfaces();

            foreach (var baseInterface in baseInterfaces)
            {
                foreach (var piBase in baseInterface.GetProperties())
                {
                    AddPropertyCode(code, piBase);
                }
            }

            code.AppendLine();
            code.AppendLine("   }");
            code.AppendLine("}");

            MetadataReference[] references = GetMetadataReferences(interfaceType, parentType);
            return ImplementDynamicType(code.ToString(), assemblyName, references);
        }

        private static void AddPropertyCode(StringBuilder code, PropertyInfo pi)
        {
            code.AppendLine($"      public {GetSourceCodeTypeName(pi.PropertyType)} {pi.Name} {{get; set;}}");
            code.AppendLine();
        }
#endif

        /// <summary>
        /// Gets the type associated with the specified name.
        /// </summary>
        /// <param name="typeName">Full name of the type.</param>
        /// <param name="type">The type.</param>
        /// <param name="customAssemblies">Additional loaded assemblies (optional).</param>
        /// <returns>Returns <c>true</c> if the type was found; otherwise <c>false</c>.</returns>
        public static bool TryGetTypeByName(string typeName, out Type type, params Assembly[] customAssemblies)
        {
            type = null;

            if (typeName.Contains("Version=")
                && !typeName.Contains("`"))
            {
                // remove full qualified assembly type name
                typeName = typeName.Substring(0, typeName.IndexOf(','));
            }

            int genericCharIndex = typeName.IndexOfAny(GenericTypeChars);

            if (genericCharIndex >= 0)
            {
                // try get generic types
                if (typeName[genericCharIndex] == '`')
                {
                    // check if generic definition contains type parameters
                    if (typeName.IndexOf('[', genericCharIndex) > genericCharIndex)
                    {
                        var match = Regex.Match(typeName, "(?<MainType>.+`(?<ParamCount>[0-9]+))\\[(?<Types>.*)\\]");

                        if (match.Success)
                        {
                            int genericParameterCount = int.Parse(match.Groups["ParamCount"].Value);
                            string genericDef = match.Groups["Types"].Value;
                            List<string> typeArgs = new List<string>(genericParameterCount);
                            foreach (Match typeArgMatch in Regex.Matches(genericDef, "\\[(?<Type>.*?)\\],?"))
                            {
                                if (typeArgMatch.Success)
                                {
                                    typeArgs.Add(typeArgMatch.Groups["Type"].Value.Trim());
                                }
                            }

                            Type[] genericArgumentTypes = new Type[typeArgs.Count];
                            for (int genTypeIndex = 0; genTypeIndex < typeArgs.Count; genTypeIndex++)
                            {
                                Type genericType;
                                if (TryGetTypeByName(typeArgs[genTypeIndex], out genericType, customAssemblies))
                                {
                                    genericArgumentTypes[genTypeIndex] = genericType;
                                }
                                else
                                {
                                    // cant find generic type
                                    return false;
                                }
                            }

                            string genericTypeString = match.Groups["MainType"].Value;
                            Type genericMainType;
                            if (TryGetTypeByName(genericTypeString, out genericMainType))
                            {
                                // make generic type
                                type = genericMainType.MakeGenericType(genericArgumentTypes);
                            }
                        }
                    }
                    else
                    {
                        // try to get plain generic type (without type parameters)
                        type = Type.GetType(typeName);

                        if (type == null)
                        {
                            type = GetTypeFromAssemblies(typeName, customAssemblies);
                        }
                    }
                }
                else if (typeName[genericCharIndex] == '<')
                {
                    var match = Regex.Match(typeName, "(?<MainType>.+)<(?<Types>.+)>");

                    if (match.Success)
                    {
                        string genericDef = match.Groups["Types"].Value;
                        string[] typeArgs = genericDef.Split(',');


                        Type[] genericArgumentTypes = new Type[typeArgs.Length];
                        for (int genTypeIndex = 0; genTypeIndex < typeArgs.Length; genTypeIndex++)
                        {
                            Type genericType;
                            if (TryGetTypeByName(typeArgs[genTypeIndex].Trim(), out genericType, customAssemblies))
                            {
                                genericArgumentTypes[genTypeIndex] = genericType;
                            }
                            else
                            {
                                // cant find generic type
                                return false;
                            }
                        }

                        string genericTypeString = string.Concat(match.Groups["MainType"].Value, "`", typeArgs.Length);
                        Type genericMainType;
                        if (TryGetTypeByName(genericTypeString, out genericMainType))
                        {
                            // make generic type
                            type = genericMainType.MakeGenericType(genericArgumentTypes);
                        }
                    }
                }
            }
            else
            {
                type = Type.GetType(typeName);

                if (type == null)
                {
                    type = GetTypeFromAssemblies(typeName, customAssemblies);
                }
            }


            return type != null;
        }

        private static Type GetTypeFromAssemblies(string typeName, params Assembly[] customAssemblies)
        {
            Type type = null;

            if (customAssemblies != null
               && customAssemblies.Length > 0)
            {
                foreach (var assembly in customAssemblies)
                {
                    type = assembly.GetType(typeName);

                    if (type != null)
                        return type;
                }
            }

            var loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (var assembly in loadedAssemblies)
            {
                type = assembly.GetType(typeName);

                if (type != null)
                    return type;
            }

            return type;
        }


#if AheadOfTimeOnly
        public static Type BuildProxyImplementation(Type interfaceType)
        {
            StringBuilder sourceCode = BuildProxyImplementationSource(interfaceType);
            throw new NotSupportedException($"This IOCTalk.Common version is compiled with ahead of time only. This means you must provide a local proxy implementation for the interface {interfaceType.FullName}.  If your platform supports roslyn runtime compilation you can switch to the full version. {Environment.NewLine} Source code sample: {Environment.NewLine}{sourceCode.ToString()}");
        }
#else

        /// <summary>
        /// Builds the proxy implementation.
        /// </summary>
        /// <param name="interfaceType">Type of the interface.</param>
        /// <param name="addDebugInformation">if set to <c>true</c> [add debug information].</param>
        /// <param name="communicationServiceImportAttributeSource">The communication service import attribute source code.</param>
        /// <returns></returns>
        public static Type BuildProxyImplementation(Type interfaceType)
        {
            StringBuilder source = BuildProxyImplementationSource(interfaceType);

            return ImplementDynamicType(source.ToString(), "IOCTalk.AutoGeneratedProxies." + interfaceType.Name, GetMetadataReferences(typeof(TypeService), interfaceType));
        }

#endif

        public static StringBuilder BuildProxyImplementationSource(Type interfaceType)
        {
            if (!interfaceType.IsInterface)
                throw new Exception("Type must be an interface!");

            string name = interfaceType.Name + "AutoGeneratedProxy";

            StringBuilder source = new StringBuilder();

            source.AppendLine("using System;");
            source.AppendLine("using BSAG.IOCTalk.Common.Reflection;");
            source.AppendLine("using BSAG.IOCTalk.Common.Interface.Reflection;");
            source.AppendLine("using BSAG.IOCTalk.Common.Interface.Session;");
            source.AppendLine("using BSAG.IOCTalk.Common.Interface.Communication;");

            source.AppendLine();
            source.Append("namespace ");
            source.AppendLine(AutoGeneratedProxiesNamespace);
            source.AppendLine("{");
            source.AppendFormat(" public class {0} : {1}", name, interfaceType.FullName);
            source.AppendLine(" {");
            List<string> referencedAssemblies = new List<string>();
            CreateProxyInterfaceMethodSourceCode(source, interfaceType, referencedAssemblies);

            // add communication service field
            source.AppendLine();
            source.Append("     ");
            source.AppendLine("     private IGenericCommunicationService communicationService;");
            source.AppendLine("     private ISession session;");
            source.AppendLine();

            // add constructor
            source.AppendLine($"    public {name}(IGenericCommunicationService commService, ISession session)");
            source.AppendLine("     {");
            source.AppendLine("         this.communicationService = commService;");
            source.AppendLine("         this.session = session;");
            source.AppendLine("     }");


            source.AppendLine(" }");
            source.AppendLine("}");
            return source;
        }

        private static string GetAssemblyPath(Type type)
        {
            return new Uri(type.Assembly.CodeBase).LocalPath;
        }

        private static void CreateProxyInterfaceMethodSourceCode(StringBuilder mainSource, Type interfaceType, IList<string> referencedAssemblies)
        {
            string methodBodyIntention = "\t\t";
            string methodLineIntention = "\t\t\t";


            foreach (var method in GetMethodsByType(interfaceType))
            {
                StringBuilder sbInvokeInfoMember = new StringBuilder();
                sbInvokeInfoMember.AppendLine();

                StringBuilder methodSource = new StringBuilder();

                bool isReturnRequired;
                string returnType;
                if (method.ReturnType == typeof(void))
                {
                    isReturnRequired = false;
                    returnType = "void";
                }
                else
                {
                    isReturnRequired = true;
                    returnType = GetSourceCodeTypeName(method.ReturnType);
                }

                methodSource.AppendLine();
                methodSource.AppendFormat("{0}public {1} {2}(", methodBodyIntention, returnType, method.Name);

                string invokeInfoMemberName = string.Format("methodInfo{0}_", method.Name);

                List<ParameterInfo> outParameters = null;
                StringBuilder sbParameterValues = null;
                StringBuilder sbParameterTypes = null;

                var parameters = method.GetParameters();

                sbParameterTypes = new StringBuilder();
                sbParameterTypes.Append("new Type[] { ");

                if (parameters.Length > 0)
                {
                    sbParameterValues = new StringBuilder();
                    sbParameterValues.Append(methodLineIntention);
                    sbParameterValues.Append("object[] parameterValues = new object[] { ");

                    for (int i = 0; i < parameters.Length; i++)
                    {
                        var param = parameters[i];

                        Type paramType = param.ParameterType;
                        string decoration = null;
                        if (param.IsOut)
                        {
                            decoration = "out";
                            paramType = paramType.GetElementType();

                            if (outParameters == null)
                                outParameters = new List<ParameterInfo>();

                            outParameters.Add(param);
                        }

                        string parameterTypeString = GetSourceCodeTypeName(paramType);

                        methodSource.AppendFormat("{0} {1} {2}", decoration, parameterTypeString, param.Name);

                        string invokeInfoMemberTypeName = string.Concat(decoration, parameterTypeString);
                        invokeInfoMemberTypeName = Regex.Replace(invokeInfoMemberTypeName, @"[^a-zA-Z0-9]", "");    // remove invalid chars
                        invokeInfoMemberName += invokeInfoMemberTypeName;

                        // add reference to parameter value array
                        if (param.IsOut)
                        {
                            // out parameter -> pass null
                            sbParameterValues.Append("null");
                        }
                        else
                        {
                            sbParameterValues.Append(param.Name);
                        }

                        // type array
                        sbParameterTypes.AppendFormat("typeof({0}){1}", parameterTypeString, (param.IsOut ? ".MakeByRefType()" : null));


                        if (i < parameters.Length - 1)
                        {
                            methodSource.Append(", ");
                            sbParameterValues.Append(", ");
                            sbParameterTypes.Append(", ");
                        }

                        // check if assembly load is required
                        if (interfaceType.Assembly != paramType.Assembly
                            && !paramType.FullName.StartsWith("System."))
                        {
                            string assemblyPath = GetAssemblyPath(paramType);

                            if (!referencedAssemblies.Contains(assemblyPath))
                            {
                                referencedAssemblies.Add(assemblyPath);
                            }
                        }
                    }

                    sbParameterValues.AppendLine(" };");
                }

                sbParameterTypes.Append(" } ");

                methodSource.AppendLine(")");

                methodSource.Append(methodBodyIntention);
                methodSource.AppendLine("{");

                if (sbParameterValues != null)
                {
                    methodSource.Append(sbParameterValues);
                }

                sbInvokeInfoMember.Append(methodBodyIntention);
                sbInvokeInfoMember.AppendFormat("private static IInvokeMethodInfo {0} = new InvokeMethodInfo(typeof({1}), \"{2}\", {3});", invokeInfoMemberName, interfaceType.FullName, method.Name, sbParameterTypes.ToString());
                sbInvokeInfoMember.AppendLine();

                methodSource.Append(methodLineIntention);

                if (isReturnRequired)
                    methodSource.Append("object result =  ");

                //methodSource.AppendFormat("CommunicationService.InvokeMethod(this, typeof({0}).GetMethod(\"{1}\", {2}), {3});", interfaceType.FullName, method.Name, sbParameterTypes.ToString(), (sbParameterValues != null ? "parameterValues" : "null"));
                methodSource.AppendFormat("communicationService.InvokeMethod(this, {0}, session, {1});", invokeInfoMemberName, (sbParameterValues != null ? "parameterValues" : "null"));
                methodSource.AppendLine();

                if (outParameters != null)
                {
                    // assign out parameters
                    foreach (var outParam in outParameters)
                    {
                        methodSource.AppendFormat("{0}{1} = ({2})parameterValues[{3}];", methodLineIntention, outParam.Name, outParam.ParameterType.GetElementType().FullName, outParam.Position);
                        methodSource.AppendLine();
                    }
                }

                if (isReturnRequired)
                {
                    methodSource.AppendFormat("{0}return ({1})result;", methodLineIntention, returnType);
                    methodSource.AppendLine();
                }

                methodSource.Append(methodBodyIntention);
                methodSource.AppendLine("}");
                methodSource.AppendLine();

                // add to main source
                mainSource.Append(sbInvokeInfoMember);
                mainSource.Append(methodSource);
            }
        }


        /// <summary>
        /// Gets the name of the parameter type.
        /// </summary>
        /// <param name="paramType">Type of the param.</param>
        /// <returns></returns>
        public static string GetSourceCodeTypeName(Type paramType)
        {
            string parameterTypeString;
            if (paramType.IsGenericType)
            {
                Type genericType = paramType.GetGenericTypeDefinition();
                string[] genericArgTypes = paramType.GetGenericArguments().Select(g => g.FullName).ToArray<string>();

                parameterTypeString = string.Concat(genericType.FullName.Replace("`" + genericArgTypes.Length, ""), "<", string.Join(",", genericArgTypes), ">");
            }
            else
            {
                parameterTypeString = paramType.FullName;
            }
            return parameterTypeString;
        }




        /// <summary>
        /// Gets the methods without get/set properties.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns></returns>
        public static IList<MethodInfo> GetMethodsByType(Type type)
        {
            return type.GetMethods(BindingFlags.Instance | BindingFlags.Public)
                .Where(m => !m.IsSpecialName).ToList<MethodInfo>();
        }


        /// <summary>
        /// Gets the method by the given name. The name can contain a qualified parameter list.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns></returns>
        public static MethodInfo GetMethodByName(Type type, string name)
        {
            if (name[name.Length - 1] == ')')
            {
                // full qualified parameter list
                int paramStartIndex = name.IndexOf('(');
                string methodName = name.Substring(0, paramStartIndex);

                string parameterListStr = name.Substring(paramStartIndex + 1, name.Length - paramStartIndex - 2);

                Type[] parameterTypes;
                if (parameterListStr.Length == 0)
                {
                    parameterTypes = new Type[0];
                }
                else
                {
                    string[] parameterListArrayStr = parameterListStr.Split(',');
                    parameterTypes = new Type[parameterListArrayStr.Length];

                    for (int i = 0; i < parameterListArrayStr.Length; i++)
                    {
                        string typeName = parameterListArrayStr[i];

                        Type paramType;
                        if (TryGetTypeByName(typeName, out paramType))
                        {
                            parameterTypes[i] = paramType;
                        }
                        else
                        {
                            throw new InvalidOperationException("Can't find the parameter type: \"" + typeName + "\"; Method: \"" + type.FullName + "." + name + "\"");
                        }
                    }
                }

                return type.GetMethod(methodName, parameterTypes);
            }
            else
            {
                return type.GetMethod(name);
            }
        }

        /// <summary>
        /// Gets the name of the method including the type parameters.
        /// </summary>
        /// <param name="methodInfo">The method info.</param>
        /// <returns></returns>
        public static string GetQualifiedMethodName(MethodInfo methodInfo)
        {
            return GetQualifiedMethodName(methodInfo, methodInfo.GetParameters());
        }

        /// <summary>
        /// Gets the name of the method including the type parameters.
        /// </summary>
        /// <param name="methodInfo">The method info.</param>
        /// <param name="parameterInfos">The parameter infos.</param>
        /// <returns></returns>
        internal static string GetQualifiedMethodName(MethodInfo methodInfo, ParameterInfo[] parameterInfos)
        {
            StringBuilder sbQualifiedMethodName = new StringBuilder();
            sbQualifiedMethodName.Append(methodInfo.Name);
            sbQualifiedMethodName.Append("(");

            foreach (var paramInfo in parameterInfos)
            {
                sbQualifiedMethodName.Append(GetSourceCodeTypeName(paramInfo.ParameterType));
                sbQualifiedMethodName.Append(",");
            }

            if (parameterInfos.Length > 0)
            {
                // remove last comma
                sbQualifiedMethodName.Length -= 1;
            }
            sbQualifiedMethodName.Append(")");

            return sbQualifiedMethodName.ToString();
        }

        /// <summary>
        /// Creates a new object instance of the given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>System.Object.</returns>
        public static object CreateInstance(Type type)
        {
            Func<object> constructorDelegate;
            if (!constructorDelegateCache.TryGetValue(type, out constructorDelegate))
            {
                lock (syncObj)
                {
                    if (!constructorDelegateCache.TryGetValue(type, out constructorDelegate))   // recheck
                    {
                        constructorDelegate = CompileConstructorDelegate(type);
                        constructorDelegateCache[type] = constructorDelegate;
                    }
                }
            }

            return constructorDelegate();
        }

        private static Func<object> CompileConstructorDelegate(Type type)
        {
            var ctor = type.GetConstructor(new Type[0]);

            // Make a NewExpression that calls the ctor with the args we just created
            NewExpression newExp = Expression.New(ctor);

            // Create a lambda with the New expression as body and our param object[] as arg
            LambdaExpression lambda = Expression.Lambda(typeof(Func<object>), newExp);

            // Compile it
            Func<object> compiled = (Func<object>)lambda.Compile();
            return compiled;
        }

        /// <summary>
        /// Creates a new object instance of the given type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>System.Object.</returns>
        public static object CreateInstance(Type type, Func<Type, string, Type, object> constructorParamResolver, out object[] outParams, out ParameterInfo[] outParamsInfo)
        {
            ConstructorParamsCache paramsCache;
            Func<object[], object> constructorDelegate;
            if (!constructorDelegateCacheParams.TryGetValue(type, out paramsCache))
            {
                lock (syncObj)
                {
                    if (!constructorDelegateCacheParams.TryGetValue(type, out paramsCache))   // recheck
                    {
                        Type[] paramTypes;
                        string[] paramNames;
                        ParameterInfo[] outParamsInternal;
                        ParameterInfo[] parameters;
                        constructorDelegate = CompileConstructorParamDelegate(type, out paramTypes, out paramNames, out outParamsInternal, out parameters);
                        paramsCache = new ConstructorParamsCache()
                        {
                            ConstructorDelegate = constructorDelegate,
                            ParamTypes = paramTypes,
                            ParamNames = paramNames,
                            ContainsOutParams = outParamsInternal != null,
                            Parameters = parameters,
                            OutParams = outParamsInternal,
                        };
                        constructorDelegateCacheParams[type] = paramsCache;
                    }
                }
            }

            object[] ctorParams = new object[paramsCache.ParamTypes.Length];
            for (int i = 0; i < paramsCache.ParamTypes.Length; i++)
            {
                if (!paramsCache.Parameters[i].IsOut)
                    ctorParams[i] = constructorParamResolver(paramsCache.ParamTypes[i], paramsCache.ParamNames[i], type);
            }

            if (paramsCache.ContainsOutParams)
            {
                // slow execution to get out values
                //todo: implement the same optimized compiled version for out param determintation
                var result = Activator.CreateInstance(type, ctorParams);
                outParams = new object[paramsCache.OutParams.Length];
                for (int i = 0; i < paramsCache.OutParams.Length; i++)
                {
                    var outP = paramsCache.OutParams[i];
                    outParams[i] = ctorParams[outP.Position];
                }
                outParamsInfo = paramsCache.OutParams;
                return result;
            }
            else
            {

                outParams = null;
                outParamsInfo = null;
                return paramsCache.ConstructorDelegate(ctorParams);
            }
        }

        private static Func<object[], object> CompileConstructorParamDelegate(Type type, out Type[] paramTypes, out string[] paramNames, out ParameterInfo[] outParams, out ParameterInfo[] cParams)
        {
            var constructor = type.GetConstructors().First();
            cParams = constructor.GetParameters();
            bool containsOutParams = cParams.Where(p => p.IsOut).Any();

            paramTypes = cParams.Select(p => p.ParameterType).ToArray();
            paramNames = cParams.Select(p => p.Name).ToArray();

            if (containsOutParams)
            {
                // skip constructor expression compilation
                outParams = cParams.Where(p => p.IsOut).ToArray();
                return null;
            }

            var args = Expression.Parameter(typeof(object[]), "args");
            var body = Expression.New(constructor,
                paramTypes.Select((t, i) => Expression.Convert(Expression.ArrayIndex(args, Expression.Constant(i)), t)).ToArray());
            var outer = Expression.Lambda<Func<object[], object>>(body, args);
            outParams = null;
            return outer.Compile();
        }

        private class ConstructorParamsCache
        {
            public Func<object[], object> ConstructorDelegate { get; set; }

            public Type[] ParamTypes { get; set; }

            public string[] ParamNames { get; set; }

            public bool ContainsOutParams { get; set; }

            public ParameterInfo[] Parameters { get; set; }

            public ParameterInfo[] OutParams { get; set; }
        }



        /// <summary>
        /// Generates the getter function.
        /// Code snippet source: https://stackoverflow.com/questions/27943121/get-accessors-from-propertyinfo-as-funcobject-and-actionobject-delegates
        /// </summary>
        /// <param name="pi">The property info.</param>
        /// <returns>Func&lt;System.Object, System.Object&gt;.</returns>
        public static Func<object, object> GenerateGetterFunc(this PropertyInfo pi)
        {
            var expParam = Expression.Parameter(typeof(object), "p");
            var expParamTyped = Expression.Convert(expParam, pi.DeclaringType);

            var expMember = Expression.MakeMemberAccess(expParamTyped, pi);

            var expMemberTyped = Expression.Convert(expMember, typeof(object));

            var exp = Expression.Lambda<Func<object, object>>(expMemberTyped, expParam);

            return exp.Compile();
        }

        /// <summary>
        /// Generates the setter action.
        /// Code snippet source: https://stackoverflow.com/questions/27943121/get-accessors-from-propertyinfo-as-funcobject-and-actionobject-delegates
        /// </summary>
        /// <param name="pi">The property info</param>
        /// <returns>Action&lt;System.Object, System.Object&gt;.</returns>
        public static Action<object, object> GenerateSetterAction(this PropertyInfo pi)
        {
            var expParam = Expression.Parameter(typeof(object), "p");
            var expParamTyped = Expression.Convert(expParam, pi.DeclaringType);

            var expParamValue = Expression.Parameter(typeof(object), "v");
            var expParamValueTyped = Expression.Convert(expParamValue, pi.PropertyType);

            var expCall = Expression.Call(expParamTyped, pi.GetSetMethod(), expParamValueTyped);

            var exp = Expression.Lambda<Action<object, object>>(expCall, expParam, expParamValue);

            return exp.Compile();
        }

#if !AheadOfTimeOnly

        public static Type ImplementDynamicType(string csharpCode, string targetAssemblyName)
        {
            return ImplementDynamicType(csharpCode, targetAssemblyName, null);
        }

        public static Type ImplementDynamicType(string csharpCode, string targetAssemblyName, MetadataReference[] references)
        {
            if (references == null || references.Length == 0)
            {
                references = GetMetadataReferences();
            }

            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(csharpCode);

            var options = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);

            CSharpCompilation compilation = CSharpCompilation.Create(
                        targetAssemblyName,
                        syntaxTrees: new[] { syntaxTree },
                        references: references,
                        options: options);

            using (var ms = new MemoryStream())
            {
                EmitResult result = compilation.Emit(ms);

                if (!result.Success)
                {
                    IEnumerable<Diagnostic> failures = result.Diagnostics.Where(diagnostic =>
                        diagnostic.IsWarningAsError ||
                        diagnostic.Severity == DiagnosticSeverity.Error);

                    StringBuilder errors = new StringBuilder();
                    foreach (Diagnostic diagnostic in failures)
                    {
                        errors.AppendFormat("{0}: {1}\n", diagnostic.Id, diagnostic.GetMessage());
                    }

                    throw new TypeAccessException($"Unable to create dynamic type for code:\n{csharpCode}\n\nErrors:\n{errors}");
                }
                else
                {
                    ms.Seek(0, SeekOrigin.Begin);
                    Assembly assembly = Assembly.Load(ms.ToArray());

                    return assembly.GetTypes().First();
                }
            }

        }

        private static MetadataReference[] GetMetadataReferences(params Type[] types)
        {

            //List<MetadataReference> refs = new List<MetadataReference>();

            ////refs.Add(MetadataReference.CreateFromAssembly(typeof(object).Assembly));
            ////refs.Add(MetadataReference.CreateFromAssembly(Assembly.Load("netstandard, Version=2.0.0.0")));



            //var path = System.Reflection.Assembly.GetExecutingAssembly().Location;
            //var name = System.IO.Path.GetFileName(path);

            //if (File.Exists(path))
            //{
            //    string dir = Path.GetDirectoryName(path);
            //    string[] files = Directory.GetFiles(dir);
            //}

            //path = Assembly.GetCallingAssembly().Location;
            //{
            //    string dir = Path.GetDirectoryName(path);
            //    string[] files = Directory.GetFiles(dir);
            //}

            ////var ase = Assembly.Load("netstandard, Version=2.0.0.0");
            ////var files = ase.GetFiles();
            ////var names = ase.GetReferencedAssemblies();
            ////var modules = ase.GetModules();

            ////if (File.Exists(loc2))
            ////{
            ////    string[] files = Directory.GetFiles(loc2);
            ////}

            // does not work with xamarin andorid! No solution found yet!


            List<string> referenceLocations = new List<string>();
            var mscorelib = typeof(object).Assembly;
            referenceLocations.Add(mscorelib.Location);
            referenceLocations.Add(Assembly.Load("netstandard, Version=2.0.0.0").Location);

            // add System.Runtime workaround
            string fwPath = Path.GetDirectoryName(typeof(object).Assembly.Location);
            string runtimeWorkaroundPath = Path.Combine(fwPath, "System.Runtime.dll");
            if (File.Exists(runtimeWorkaroundPath))
            {
                referenceLocations.Add(runtimeWorkaroundPath);
            }
            else
            {
                Console.WriteLine($"netcore framework directory path not found! path: {runtimeWorkaroundPath}");
            }

            // add given type assemblies
            if (types != null)
            {
                foreach (var type in types)
                {
                    if (type != null)
                    {
                        referenceLocations.Add(GetAssemblyPath(type));

                        if (type.IsGenericType)
                        {
                            foreach (var genArgType in type.GetGenericArguments())
                            {
                                referenceLocations.Add(GetAssemblyPath(genArgType));
                            }
                        }
                    }
                }
            }


            MetadataReference[] references = referenceLocations.Distinct()/*.Where(fileLoc => File.Exists(fileLoc))*/.Select(loc => MetadataReference.CreateFromFile(loc)).Cast<MetadataReference>().ToArray();
            return references;
        }

#endif
    }
}
